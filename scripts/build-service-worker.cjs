const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');

const listFiles = (baseDir, options) => {
    const { extensions, recursive = false, prefix = '' } = options;
    const results = [];
    const dirPath = path.join(ROOT, baseDir);

    if (!fs.existsSync(dirPath)) {
        return results;
    }

    const entries = fs.readdirSync(dirPath, { withFileTypes: true });
    for (const entry of entries) {
        const relative = path.join(prefix, entry.name);
        const fullPath = path.join(dirPath, entry.name);
        if (entry.isDirectory()) {
            if (recursive) {
                results.push(...listFiles(path.join(baseDir, entry.name), {
                    extensions,
                    recursive,
                    prefix: relative
                }));
            }
            continue;
        }
        const matchesExtension = extensions.some((ext) =>
            entry.name.toLowerCase().endsWith(ext)
        );
        if (matchesExtension) {
            results.push(`/${relative.replace(/\\/g, '/')}`);
        }
    }
    return results;
};

const files = new Set([
    '/',
    '/index.html',
    '/manifest.webmanifest'
]);

[
    ...listFiles('html', { extensions: ['.html'], recursive: true, prefix: 'html' }),
    ...listFiles('css', { extensions: ['.css'], recursive: false, prefix: 'css' }),
    ...listFiles('assets', { extensions: ['.svg', '.png', '.jpg', '.jpeg', '.webp', '.ogg', '.mp3', '.wav'], recursive: true, prefix: 'assets' }),
    ...listFiles('dist', { extensions: ['.js'], recursive: true, prefix: 'dist' })
].forEach((file) => files.add(file));

const urls = Array.from(files).sort();

const serviceWorker = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file is automatically generated by scripts/build-service-worker.cjs
 * Run "npm run build" or "npm run build:sw" to regenerate.
 */

/// <reference lib="webworker" />
const PRECACHE_URLS = ${JSON.stringify(urls, null, 4)};

const CACHE_NAME = 'explosive-candy-cache-v1';
const RUNTIME_CACHE = 'explosive-candy-runtime-v1';
const FALLBACK_URL = '/index.html';
const sw = self;

sw.addEventListener('install', (event) => {
    event.waitUntil(
        (async () => {
            const cache = await caches.open(CACHE_NAME);
            await cache.addAll(PRECACHE_URLS);
            await sw.skipWaiting();
        })()
    );
});

sw.addEventListener('activate', (event) => {
    event.waitUntil(
        (async () => {
            const cacheNames = await caches.keys();
            await Promise.all(
                cacheNames.map((name) => {
                    if (name !== CACHE_NAME && name !== RUNTIME_CACHE) {
                        return caches.delete(name);
                    }
                    return Promise.resolve();
                })
            );
            await sw.clients.claim();
        })()
    );
});

sw.addEventListener('fetch', (event) => {
    if (event.request.method !== 'GET') {
        return;
    }
    const requestUrl = new URL(event.request.url);
    if (requestUrl.origin !== self.location.origin) {
        return;
    }

    if (requestUrl.pathname.startsWith('/backend')) {
        return;
    }

    event.respondWith(
        caches.match(event.request).then((cachedResponse) => {
            if (cachedResponse) {
                return cachedResponse;
            }
            return fetch(event.request)
                .then((networkResponse) => {
                    if (!networkResponse || networkResponse.status >= 400) {
                        return networkResponse;
                    }
                    const responseToCache = networkResponse.clone();
                    void caches.open(RUNTIME_CACHE).then((cache) => {
                        cache.put(event.request, responseToCache);
                    });
                    return networkResponse;
                })
                .catch(() => {
                    if (event.request.mode === 'navigate') {
                        return caches.match(FALLBACK_URL).then((fallback) => {
                            return (
                                fallback ??
                                new Response('Offline', {
                                    status: 503,
                                    statusText: 'Offline'
                                })
                            );
                        });
                    }
                    return new Response('Offline', { status: 503, statusText: 'Offline' });
                });
        })
    );
});
`;

const outputPath = path.join(ROOT, 'service-worker.js');
fs.writeFileSync(outputPath, serviceWorker);

console.log(`Generated service-worker.js with ${urls.length} precache URLs.`);
